# 銀行家のキュー(永続化キュー)

## 概要

永続化データ構造、響きがカッコいい

## 何ができる？

以下の操作が **均し計算量** O(1)で行える
i回目の操作として
- 過去の **任意の時刻tにおける** キューに値をpushして Q_i とする
- 過去の **任意の時刻tにおける** キューから値をpopして Q_i とする (popされた値も取得する)

### 実装のメモ(はしりがき)

画像が大きいので末尾の備考欄を参照


### がんばった
ひとまずは参考リンクの実装例は見ず、自分の力で実装しようとした  
結果としてはほぼ実装例を追いかける形になってしまったが、先に「分かったところ」と「後ここだけが腑に落ちないとこと」を分離しておけたので得るものは増えたのではないかと思う。  

実装で詰まった時に
- 本来想定される動きをつかんでおく
- 操作を適切に抽象化、グループ分けできるようになる
辺りができるように力をつけていきたい。まあ、後者は時間をかけて何かを整備する用なのでプログラミングコンテスト本番ではあまり役に立たないかもしれないが...

Nodeを3つに分けた(=ただoverrideするだけでなくて、練習用なので明示的に分けて)のは良かった。  
デバッグが楽になった

### 実装に当たって参考にしたものなど
https://37zigen.com/bankers-queue/  
基本的にこれをずっと眺めていました 楽しいです ありがとうございます

http://www.kmonos.net/pub/Presen/PFDS.pdf  
ちょっとだけ見た
 
https://honto.jp/netstore/pd-book_28387322.html  
(読んでない)償却計算量にはわくわくする要素が詰まっている気がするけれど、そのためだけにHaskellを習得→この本を読み切るのは重過ぎる...

## verify 
https://judge.yosupo.jp/submission/55585

## 備考(調査、実装中のメモ)
![image1](https://user-images.githubusercontent.com/37926549/128643110-0b669b0d-fc9b-4ccd-b99c-63f25a323230.jpeg)  
![image2](https://user-images.githubusercontent.com/37926549/128643112-3f8cc509-4f28-4c9a-b8a4-919829ca9e32.jpeg)  
![image3](https://user-images.githubusercontent.com/37926549/128643114-da22f2b7-16ef-4f3d-8262-51284246269b.jpeg)  
